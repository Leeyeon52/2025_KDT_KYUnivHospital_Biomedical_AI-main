<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dental GLB Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- ✅ Socket.IO 클라이언트 스크립트 추가 -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.160.0";
    import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader";
    import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls";
    import { Box3, Vector3 } from "https://esm.sh/three@0.160.0";

    let loadedModel = null;
    let pendingHighlight = null;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.5, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7);
    scene.add(light);

    const loader = new GLTFLoader();
    loader.load('./model/open_mouth.glb',
      (gltf) => {
        loadedModel = gltf.scene;
        scene.add(loadedModel);
        console.log("✅ 모델 로드 성공");

        // ✅ 모델 중심 기준 카메라 조정
        const box = new Box3().setFromObject(loadedModel);
        const center = new Vector3();
        box.getCenter(center);
        const size = box.getSize(new Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        const cameraZ = Math.abs(maxDim / Math.sin(fov / 2)) * 1.2;

        controls.target.copy(center);
        controls.update();
        camera.position.set(center.x, center.y, cameraZ);

        // ✅ 객체 탐색 로그
        loadedModel.traverse((obj) => {
          if (obj.name && obj.type === "Mesh") {
            console.log("🦷 탐색된 객체:", obj.name);
          }
        });

        if (pendingHighlight) {
          highlightTeeth(pendingHighlight);
          pendingHighlight = null;
        }
      },
      undefined,
      (err) => {
        console.error("❌ 모델 로딩 실패:", err);
      }
    );

    // ✅ highlight 함수
    function highlightTeeth(toothLabels) {
      console.log("🎯 하이라이트 요청:", toothLabels);
      const labelSet = new Set(toothLabels.map(label => label.toLowerCase().trim()));

      loadedModel.traverse((obj) => {
        if (!obj.name || obj.type !== "Mesh") return;

        const objName = obj.name.toLowerCase().trim();
        const matched = labelSet.has(objName);

        // ✅ 최초 저장된 재질이 없다면 저장
        if (!obj.userData.originalMaterial) {
          obj.userData.originalMaterial = obj.material.clone();
        }

        console.log(`🔍 탐색: ${obj.name} → ${matched ? "✅ 일치" : "❌ 불일치"}`);

        if (matched) {
          obj.material = new THREE.MeshStandardMaterial({
            color: 0xff4444,
            transparent: true,
            opacity: 1.0,
            emissive: 0x770000,
          });
          console.log(`🎯 하이라이트 적용: ${obj.name}`);
        } else {
          // ✅ 원래 재질로 복원
          obj.material = obj.userData.originalMaterial.clone();
        }
      });
    }


    // ✅ WebSocket 수신 (Flask-SocketIO와 연결)
    const socket = io("http://localhost:5000"); // ← 주소 확인

    socket.on("connect", () => {
      console.log("🧩 WebSocket 연결됨");
    });

    socket.on("prediction", (data) => {
      console.log("📥 WebSocket 받은 예측:", data);
      if (data?.predictions) {
        highlightTeeth(data.predictions.map(p => p.label));
      }
    });

    // ✅ postMessage 수신도 지원 (iframe용)
    window.addEventListener("message", (event) => {
      const data = event.data;
      if (data?.predictions) {
        console.log("📥 메시지 수신:", data.predictions);
        if (!loadedModel) {
          pendingHighlight = data.predictions.map(p => p.label);
        } else {
          highlightTeeth(data.predictions.map(p => p.label));
        }
      }
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dental GLB Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- âœ… Socket.IO í´ë¼ì´ì–¸íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€ -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.160.0";
    import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader";
    import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls";
    import { Box3, Vector3 } from "https://esm.sh/three@0.160.0";

    let loadedModel = null;
    let pendingHighlight = null;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.5, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7);
    scene.add(light);

    const loader = new GLTFLoader();
    loader.load('./model/open_mouth.glb',
      (gltf) => {
        loadedModel = gltf.scene;
        scene.add(loadedModel);
        console.log("âœ… ëª¨ë¸ ë¡œë“œ ì„±ê³µ");

        // âœ… ëª¨ë¸ ì¤‘ì‹¬ ê¸°ì¤€ ì¹´ë©”ë¼ ì¡°ì •
        const box = new Box3().setFromObject(loadedModel);
        const center = new Vector3();
        box.getCenter(center);
        const size = box.getSize(new Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        const cameraZ = Math.abs(maxDim / Math.sin(fov / 2)) * 1.2;

        controls.target.copy(center);
        controls.update();
        camera.position.set(center.x, center.y, cameraZ);

        // âœ… ê°ì²´ íƒìƒ‰ ë¡œê·¸
        loadedModel.traverse((obj) => {
          if (obj.name && obj.type === "Mesh") {
            console.log("ðŸ¦· íƒìƒ‰ëœ ê°ì²´:", obj.name);
          }
        });

        if (pendingHighlight) {
          highlightTeeth(pendingHighlight);
          pendingHighlight = null;
        }
      },
      undefined,
      (err) => {
        console.error("âŒ ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨:", err);
      }
    );

    // âœ… highlight í•¨ìˆ˜
    function highlightTeeth(toothLabels) {
      console.log("ðŸŽ¯ í•˜ì´ë¼ì´íŠ¸ ìš”ì²­:", toothLabels);
      const labelSet = new Set(toothLabels.map(label => label.toLowerCase().trim()));

      loadedModel.traverse((obj) => {
        if (!obj.name || obj.type !== "Mesh") return;

        const objName = obj.name.toLowerCase().trim();
        const matched = labelSet.has(objName);

        // âœ… ìµœì´ˆ ì €ìž¥ëœ ìž¬ì§ˆì´ ì—†ë‹¤ë©´ ì €ìž¥
        if (!obj.userData.originalMaterial) {
          obj.userData.originalMaterial = obj.material.clone();
        }

        console.log(`ðŸ” íƒìƒ‰: ${obj.name} â†’ ${matched ? "âœ… ì¼ì¹˜" : "âŒ ë¶ˆì¼ì¹˜"}`);

        if (matched) {
          obj.material = new THREE.MeshStandardMaterial({
            color: 0xff4444,
            transparent: true,
            opacity: 1.0,
            emissive: 0x770000,
          });
          console.log(`ðŸŽ¯ í•˜ì´ë¼ì´íŠ¸ ì ìš©: ${obj.name}`);
        } else {
          // âœ… ì›ëž˜ ìž¬ì§ˆë¡œ ë³µì›
          obj.material = obj.userData.originalMaterial.clone();
        }
      });
    }


    // âœ… WebSocket ìˆ˜ì‹  (Flask-SocketIOì™€ ì—°ê²°)
    const socket = io("http://localhost:5000"); // â† ì£¼ì†Œ í™•ì¸

    socket.on("connect", () => {
      console.log("ðŸ§© WebSocket ì—°ê²°ë¨");
    });

    socket.on("prediction", (data) => {
      console.log("ðŸ“¥ WebSocket ë°›ì€ ì˜ˆì¸¡:", data);
      if (data?.predictions) {
        highlightTeeth(data.predictions.map(p => p.label));
      }
    });

    // âœ… postMessage ìˆ˜ì‹ ë„ ì§€ì› (iframeìš©)
    window.addEventListener("message", (event) => {
      const data = event.data;
      if (data?.predictions) {
        console.log("ðŸ“¥ ë©”ì‹œì§€ ìˆ˜ì‹ :", data.predictions);
        if (!loadedModel) {
          pendingHighlight = data.predictions.map(p => p.label);
        } else {
          highlightTeeth(data.predictions.map(p => p.label));
        }
      }
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>